클래스의 메소드 이름 검색 및 호출
클래스에 정의된 메소드 이름을 검색하고 호출할 수 있다.

일반적으로 클래스의 필드(변수)나 메소드 (함수) 이름을 미리 확정한 다음, 이를 참조하거나 호출한다.
정의되지 않은 필드 참조나 메소드 호출에 대해서는 컴파일러가 오류 처리한다.

어떤 상황에서는 어느 필드나 메소드가 클래스에 정의되어 있는지를 확인하고, 존재가 확인되면 참조하거나 호출하기를 원한다.

클래스 정의 내용을 참조하기 위해서는 해당 클래스나 객체로부터 "class"객체를 얻어내야 한다.
어느 객체로부터 "class"객체를 얻기 위해서 getClass()메소드를 이용한다.
"class"객체로부터 "Method"객체를 얻기 위해서 getDeclaredMethod()메소드를 이용한다.
해당 메소드를 호출하기 위해 invoke() 메소드를 이용한다. 이 때, 메솓 호출 대상 객체를 매개 변수로 알려준다.

메소드 뿐만 아니라 필드에 대해서도 비슷한 방법으로 간접 접근할 수 있다.

이런 방법들은 결국 프로그래머에게 관련 소스 코드가 어떻게 작성되었는가를 체크 할 수 있는 도구로 제공된다.

주어진 객체로부터 "class"클래스 객체를 얻어 지시자에 대입하는 경우 와일드 카드 타입을 사용해야 한다.
"Class" 클래스는 만능 클래스 중의 하나이다. 
이 때 타입 매개 인수 <? extendes Student> 형태는 Student클래스 및 그 후손 클래스를 모두 포함한다는 뜻이다.
<? super Student> 형태는 Student 클래스 및 그 조상 클래스를 모두 포함한다는 뜻이다.
위와 같이 여러 클래스를 포괄하는 개념을 와일드 카드 타입이라 한다.

"Class" 클래스 객체는 해당 클래스의 .class 필드로부터 얻을 수도 있다.
이 경우에는 "Class" 클래스의 타입 인수를 단정해주어야 한다. 


필드 값에 따른 메소드 선택 호출
메소드 이름 자체를 검색하는 방안 대신 특정 필드 값으로 판단할 수도 있다.

클래스에 "FlagNew"라는 필드를 추가하여 getAge()와 getAge_new()중 어느쪽 선택 표시로 사용하고자 한다.
FlagNew필드의 존재 전제 하에 그 값의 ture/flase로 결정한다.
값과 무관하게 FlagNew 필드 존재 여부 자체로 판단한다. 이를 위하여 getDeclaredField()메소드를 이용한다.
getDeclaredField() 메소드의 타입은 "Filed"클래스이다.


메소드나 필드를 위한 표식(Annotation)
단순히 필드나 메소드를 체크하는 대신, 표식을 붙여 상황을 표시할 수 있다.

표식의 기본형은 하나의 인터페이스를 정의하는 형태이고, 이 때 명시하는 인터페이스 이름이 표식 이름이 된다.
표식의 유지범위를 'Retention()' 구문으로 설정할 수 있다. 표식의 유지 범위중, 기본(생략)과 'SOURCE'는 표식이 소스 코드 자체에만 남기 때문에 주석역할만
하고 'CLASS'는 컴파일된 *.class 파일에 포함되지만 실행 주체인 jVM까지는 영향을 미치지 않는다.
유지 벙뮈 'RUNTIME'인 경우 *.class 파일에 저장되고, 실행시 검색 가능하다.

정의된 표식을 필드나 메소드 위(앞)에 붙인다.

Student클래스 객체로부터 "class" 객체를 거쳐 메소드나 필드 객체를 얻은 후, isAnnotationPresent()메소드를 이용하여 원하는 표식이 붙어 있는지 체크할수 있다.

표식으로 부터 정보를 얻어, 적합한 타입으로 메소드를 호출할 수 있다.


표식 대상 지정
정의된 표식을 붙일 수 있는 대상의 유형을 지정할 수 있다.

'Target()' 구문으로 표식을 필드에 붙일지 메소드에 붙일지 등으로 지정할 수 있다.

만약 표식을 붙인 목적 대상이 표식의 용도와 일치하지 않으면 컴파일러가 오류 처리한다.


표식 필드
표식에 일반 클래스와 같이 필드(인수)를 설정할 수 있다.

표식에 인수(필드)를 두어, 표식을 더욱 유연하게 활용할 수 있다.
c언어 매크로와 매우 유사하다.

클래스 객체로부터 필드 혹은 메소드 객체를 얻은 후 그곳에 붙어있는 표식 객체를 얻는다.

표식 객체로부터 필드 값을 얻어서 활용한다.

표식의 필드는 여러 개 둘 수 있다.

즉, 다른 프로그래머가 붙여놓은 표식을 식별하여 내 프로그램의 로직에 반영할 수 있다.


내장 표식들
사용자가 정의하는 표식 외에, 자바 컴파일러에게 미리 지정되어있는 표식들이 있다.

재정의 메소드에 @Override내장 표식을 붙이면 컴파일러는 해당 메소드가 부모 클래스에 존재하는 재정의 메소드인가를 체크해준다.





